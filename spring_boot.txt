*** Spring Boot ***

- in application.properties debug=true, spring boot will tell you what classes it has activated and what not.
- you get conditions evaluation report.
- Positive matches: these classes will be autoconfigured by the spring based on CONDITION.
- conditions can be: @ConditionalOnClass, @ConditionalOnProperty, @ConditionalOnMissingBean.
- Negative matches: these classes will not be autoconfigured by the spring boot.
- spring boot keeps a clone copy of meta data inside external libraries, spring-boot-autoconfigure/META-INF/spring/.
- spring boot configures classes based on conditions.
- SpringApplication.run returns ConfigurableApplicationContext which is an extension of Application Context, you can use
  any but ApplicationContext is readonly hence you can modify beans.


*** How spring boot works internally ***

- @SpringBootApplication - main/primary annotation, and is a combination of

- @Configuration---> for java based config approach for creating beans.
- @AutoConfiguration ---> scans pom.xml and create beans based on conditions.
- @ComponentScan ---> what all packages are needed to be scanned.

- you can override @ComponentScan annotation, just below @SpringBootApplication, you can use @ComponentScan annotation
  to override it and tell spring boot which all packages it needs to scan.
  
  @ComponentScan(basePackages="com.javatechie.a.*");


*** How spring boot works ***

1) creates application context (SpringApplication.run method)
2) checks application type (inside create application context method) (web or reactive based on this it creates AC)
3) scans and add beans to application context
4) enable embedded tomcat containers.


*** Spring Boot Conditions Annotations ***

1) 


*** Dependency Injection and Command Line Runner ***

- Stereotype annotations: @Component --> parent annotation of all listed, @Service, @Repository, @Controller
- They define roles/purpose on classes they are used.
- @Component tells spring to take care of it and add to AC
- java based approach first annotate that class with @Configure and inside it use @Bean and create method that will return
  object
- use of @Autowired

- over setters 

  @Autowired
  @Qualifier("version1")
  private WhatsappService whatsppService;

- over constructor
  @Autowired
  UserService(@Qualifier("version1") WhatsappService whatappService){
      this.whatsappService=whatsappService;
  } 


*** Preprocessing logic that you want to perform before application kicking off use CommandLineRunner ***

- implement CommandLineRunner and override run method
- this method runs after psvm is executed and application context is initialized, after it immediately executes.


*** Spring boot restful webservices *** (coding wise working of REQUEST PARAMS is remaining)

- There are 2 types of webservices

a) SOAP --> sticks to SOAP protocol, works on XML.
b) REST --> sticks to HTTP or HTTPs protocol, XML, JSON, any media type, secure and token based authentication.


-- 3 tier architecture:

- Web (endpoints) (Controller) 
- Service (business logic) (Service)
- Database (dao logic) (Repository)



-- course-service

1) add course
2) update course
3) delete course
4) view/get course


dependencies: lombok, spring web
project structure: controller, service, dto, dao, entity(model) and util(converting dto to entity and vice versa)

dto-> it is the value that will be tansferred from controller to service, the dto will then be converted into model object
to be saved inside db.


- Course
- courseId
- name
- trainerName
- duration
- startDate
- courseType
- fees
- isCertificateAvailable

- CourseService
- CourseController - @RestController

-- HTTP METHODS --

POST ---> creating resource and persisting in DB
PUT ---> modifying the resource
DELETE --> deleting the resource
GET ---> fetch the resource


-- @RequestMapping over the class
-- return type at controller, RequestEntity<?> addCourse(@RequestBody Course course) ---> @RequestBody converts JSON to
Object
-- @PostMapping("enter url here"), @GetMapping("enter url here"), @GetMapping('/{courseId}') @PathVariable Integer courseId
   @RequestParam, @JsonFormat 

-- return new ResponseEntity<>(course,HttpStatus.CREATED)

-- Lombok: @Data--> to generate both getters and setters
           @AllArgsConstructor
           @NoArgsConstructor
           @Getter
           @Setter



*** Spring Boot CRUD Example integration of in memory database H2 ***

- H2 in memory data base mainly used for testing or test cases
- couple of dependecies are required
- Spring Data JPA, Spring Data is having multiple implemenatations consider it as 
  an interface which is having implementations like JPA, MongoDB, Cassandra
- spring data jpa and h2 is added, if you want to work with sql replace h2 with sql
  driver, cassandra with cassandra driver

- entity package is used to store objects into db

entity/CourseEntity - Marked with @Entity telling jpa this object is 
going to be stored in DB,@Table(name=""), @Entity must have primary key mark any
of IV as @Id, @Generated(strategy = )


- inside dao create CourseDao Interface and extend CrudRepository<CourseEntity,
Integer>(it is )

- now telling spring boot, to view h2 console, datasource to configure in application.properties

  spring.h2.console.enabled=true
  spring.datasource.url=jdbc:h2:mem:testdb(schema name)


- inside dto create CourseRequestDTO(captures incoming req) and CourseResponseDTO(response should be captured in this and return)


- inside service class, get the courseRequestDTO and convert it into CourseEntity(Important Point)
  and save it into the db

- use CourseDao method save to save the object in db

- creating custom response

  class ServiceResponse<T>{
    private HttpStatus status;
    private T response;
  }



*** miscellaneous notes ***

- JPA(java persistence api) is a specification that tell how java objects should be mapped to database tables. It does
  not provide actual database functions, it requires an implementation, it just define rules and interfaces.

- JPA needs an implementation and this implementation is provided by Hibernate, OpenJPA.




*** Things to need double down on ***

- @JsonFormat annotation
- JPA generation for primary keys



*** Bean Validation ***

- validate the information coming from the user.
- spring boot starter validation ---> dependency

annotations used in this dependency

- @NotNull
- @NotEmpty
- @NotBlank - @NotNull + @NotEmpty
- @Min and @Max
- @Pattern
- @Email


inside courseRequestDTO:

@NotBlank(message="Course name should not be null and empty")
@NotEmpty(message="")


@Min(value=1500,message="Course price cannot be less than 1500")
@Max(value=5000,message="Course price cannot be above 5000")
private Double fees;


@Pattern(regexp="^[0-9]{10}")


in order to trigger it

- inside controller where in @RequestBody you are accepting it just append @Valid before courseRequestDTO

*** Exception Handling ***

- @RestControllerAdvice annotated over a class indicates that this is a global exception handler class
  class ApplicationExceptionHandler
  

- @ExceptionHandler(MethodArgumentNotValidException.class) if you find error of this type just call below method
  public ServiceResponse<?> handleMethodError(MethodArgumentException exception){
   
   ServiceResponse<?> sr=new ServiceResponse<>();
   List<ErrorDTO> errorDTOList=new ArrayList<>();
   exception.getBindingResult().getFieldErrors().forEach(error->{ErrorDTO err= new ErrorDTO(error.getMessage);
	errorDTOList.add(errorDTO));

   return sr;
}




- create an error DTO: List<ErrorDTO> error;



*** LOGGING ***

- logback contains : logback core and logback classic
- logback(its the implementation class)
- spring jcl(pulls above dependency) (spring commons logging)
- java util logging, log4j2, logback(default provided)
- spring boot started logging (dependency)
- spring-boot-started-web (pulls above dependency)


Logger - captures the event message.
Formatter - Formats the message captured by logger.
Handler - Dispatch the message by printing them in a file or console.

-> creating logger object 
   Logger log=LoggerFactory.getLogger(mention the class)

-> Logging Level

    - INFO (events occuring at runtime) (for prod and env)
    - DEBUG (info abt flow of system) (for developer)
    - WARN (changes due to deprecation)
    - ERROR (runtime error)

  ALL<TRACE<DEBUG<INFO<WARN<ERROR<FATAL<OFF ---> order of logging


- To enable levels:

a) logging.level.packageName.*=
b) spring.output.ansi.enabled=true
c) logging.file.name=file.log




*** Spring Boot Actuator *** (helps in monitoring
application in the production)

- spring boot actuator exposes some endpoints which
give lot of information abt ur system

- dependency: Spring Boot Actuator

- after running it exposes a new endpoint: localhost:port/actuator

- to enable all endpoints in application.properties write:
 management.endpoints.web.exposure.include=*

- some questions:

- use of @Sl4j annotation (study about logs) ------ done
- use of ObjectMapper --> converts java objects to JSON ---- done


- info endpoint of actuator, explore logfile endpoint

question on this

- check how to enable info endpoint through application.properties---> done
- how to set info properties like in application.properties ---> done, properties to first expose info and then to show
  all env related data management.info.env.enabled=true
- how to set info properties using .yml file ---> done

- to add dynmaic data to info route ---> use InfoContributor interface
- creating a custom endpoint and using inside actuator ---> pending



** Question **

- how to access properties listed inside application.properties

a) @Value annotation: e.g @Value("${app.name}")

b) Using Environment class, just autowire it and use e.g env.getProperty("info.app.name")



*** behind the scene working of email ***

- SMTP only stands ASCII text not binary, but pdfs, attachments are all binaries
- Base64 is an encoding algorithm that takes in binary values and converts them to ASCII



*** Spring Boot Email Integration ***

- Java Mail Sender dependency to be added


- in application.properties or application.yml

a) spring.mail.host= smtp.gmail.com
   spring.mail.port=587
   spring.mail.username=sujaldhiman2003@gmail.com
   spring.mail.password=
   spring.mail.properties.mail.smtp.auth



b) Autowire JavaMailSender

c) now create object of SimpleMailMessage and set all properties
   of it

d) SimpleMailMessage smp=new SimpleMailMessage()
   smp.setFrom();
   smp.setTo();
   
e) javaMailSender.send(smp);

f) MimeMessage mimeMsg = new MimeMessage() -> used when attachements
   are also there



*** heirarchy drill down ***

- SimpleMailMessage



Properties to be set:

- host, username, password, port and security properties

Classes and Interfaces Involved:

- MailSender

- JavaMailSender

- JavaMailSenderImpl

- SimpleMailMessage

- MimeMessagePreparator

- MimeMessageHelper



**** New topic regarding Streams ****

- InputStream--> use to read from a source, reads byte by byte, good for reading pdfs,images
 
- OutputStream--> writing to a source

both above inputstream and output stream deals in raw bytes, above just move bytes here and there

-- for byte streams classes responsible are InputStream and OutputStream
-- for character streams classes responsible are Reader and Writer


Java I/O is basically divided into 2 categories:

- Byte Streams  - Binary Data --> main interfaces InputStream and OutputStream  --> FileInputStream, FileOutputStream

- Character Streams  - Text Data --> main interface Reader and Writer --> FileReader and FileWriter


*** Proper Distinctions ***

- FileInputStream --> reads byte wise from source, and you get a byte source

- InputStreamReader --> coverts byte stream to character stream

- FileReader --> reads character wise and you get a character stream

- BufferedReader --> works on character stream

-  


-- topics to cover

a) All Input and Output Streams
b) Sending basic mails
c) Handling Files at backend
d) How are files actually transferred, meaning conversion to byte stream over network 
   and how in backend database to save
   



-- distinguish between: MimeMessage and MimeMessageHelper
-- Multipart



*** some key question during file handling at backend ****

How does a file from your local machine travel over the network to a backend server?

What happens behind the scenes in HTTP during a file upload?

How is the file referenced from the local machine and included in a request (like Postman or a web app)?

How does the server (like Spring Boot) receive and reconstruct the file?

What protocols, headers, encodings, and technologies are involved?


-- things done learnt how to handle file, more stuffs to work upon, distinguish between still pending




*** Spring Scheduler ***

- scheduler 

a) why to use it
b) what are the real life usecases

- some piece of code to automate using time intervals

create a new project

-> dependencies: lombok, spring web, h2, spring data jpa, 
java mail sender, apache poi--> to generate excel file

-> generating excel file steps


--> in excel first row is header, and divided into row and column

1) each segment is a cell


SXSSWorkbook workbook = new SXSSWorkbook();
Sheet sheet = workbook.createSheet();

--> first set the header
 
Row headerRow = sheet.createRow(0);
Cell headerCell = headerRow.createCell(0);
headerCell.setCellValue("ORDER_ID");

headerCell = headerRow.createCell(1)
headerCell.setCellValue("ORDER_NAME")


--> creating byte array to a resource


- create a folder as service
- inside that inject the service bean which u want to run
- e.g @Autowired NotificationService service;
- to enable scheduling: @EnableScheduling (should be kept
above the service class responsible for handling scheduling)

@Scheduled(fixedRate = 3000)
public void process(){
}

@Scheduled annotation should be written above the method
responsible for calling a particular service

@Scheduled(cron="")

- read about cron expression

** what if method took too long to execute and job is triggered?








